[{"content":"ubuntu-server虚拟机配置 Sh配置 安装完ubuntu后先配置sh这样可以通过xshell连接 只需要：\nsudo apt-get install openssh-server ssh即可 Samba配置 然后安装samba\nsudo apt-get install samba 创建share文件夹\ncd /home sudo mkdir share sudo chmod 777 share 然后在/etc/samba里配置smb.conf 文件 在文件尾部添加：\n[share] comment = My Samba path = /home/gao/share browseable = yes writeable = yes 然后设置密码\nsudo smbpasswd -a gao 然后去主机上映射盘符就可以方便的访问 在文件框内输入\\192.168.134.xxx 也就是虚拟机ip就可以 把share映射为盘符\ngcc配置 换apt阿里源：\ncd /etc/apt sudo mv source.list source.list.back sudo vim source.list 改为：\ndeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial universe deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties deb http://archive.canonical.com/ubuntu xenial partner deb-src http://archive.canonical.com/ubuntu xenial partner deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 安装gcc：\nsudo apt-get install build-essential ","date":"2020-09-10T00:00:00Z","image":"https://example.com/p/ubuntu-server%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/hudai-gayiran-3Od_VKcDEAA-unsplash_hub241c2a9c7a2caf7e16a2a5bbc7141ff_18711_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/ubuntu-server%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/","title":"ubuntu-server虚拟机配置"},{"content":"MYSQL mysql安装与配置 在虚拟机上安装mysql,使用apt-get install就可以 这里我只检索到了mysql-server-5.7就安装了5.7\n在本地win10上安装mysqlbench用于连接虚拟机的mysql服务器 这里使用网络连接，可能是因为mysql版本的原因，本来应该在/etc/mysql中的my.cnf文件中显式的配置有基本信息，我只需要修改部分，但5.7在/etc/mysql/mysql.conf.d/mysqld.cnf,在它的基础上修改对应的bind-address为0.0.0.0保证回环地址可访问：\n\r#\r# The MySQL database server configuration file.\r#\r# You can copy this to one of:\r# - \u0026quot;/etc/mysql/my.cnf\u0026quot; to set global options,\r# - \u0026quot;~/.my.cnf\u0026quot; to set user-specific options.\r# # One can use all long options that the program supports.\r# Run program with --help to get a list of available options and with\r# --print-defaults to see which it would actually understand and use.\r#\r# For explanations see\r# http://dev.mysql.com/doc/mysql/en/server-system-variables.html\r# This will be passed to all mysql clients\r# It has been reported that passwords should be enclosed with ticks/quotes\r# escpecially if they contain \u0026quot;#\u0026quot; chars...\r# Remember to edit /etc/mysql/debian.cnf when changing the socket location.\r# Here is entries for some specific programs\r# The following values assume you have at least 32M ram\r[mysqld_safe]\rsocket = /var/run/mysqld/mysqld.sock\rnice = 0\r[mysqld]\r#\r# * Basic Settings\r#\ruser = mysql\rpid-file = /var/run/mysqld/mysqld.pid\rsocket = /var/run/mysqld/mysqld.sock\rport = 3306\rbasedir = /usr\rdatadir = /var/lib/mysql\rtmpdir = /tmp\rlc-messages-dir = /usr/share/mysql\rskip-external-locking\r#\r# Instead of skip-networking the default is now to listen only on\r# localhost which is more compatible and is not less secure.\rbind-address = 0.0.0.0\r#\r# * Fine Tuning\r#\rkey_buffer_size = 16M\rmax_allowed_packet = 16M\rthread_stack = 192K\rthread_cache_size = 8\r# This replaces the startup script and checks MyISAM tables if needed\r# the first time they are touched\rmyisam-recover-options = BACKUP\r#max_connections = 100\r#table_cache = 64\r#thread_concurrency = 10\r#\r# * Query Cache Configuration\r#\rquery_cache_limit = 1M\rquery_cache_size = 16M\r#\r# * Logging and Replication\r#\r# Both location gets rotated by the cronjob.\r# Be aware that this log type is a performance killer.\r# As of 5.1 you can enable the log at runtime!\r#general_log_file = /var/log/mysql/mysql.log\r#general_log = 1\r#\r# Error log - should be very few entries.\r#\rlog_error = /var/log/mysql/error.log\r#\r# Here you can see queries with especially long duration\r#log_slow_queries = /var/log/mysql/mysql-slow.log\r#long_query_time = 2\r#log-queries-not-using-indexes\r#\r# The following can be used as easy to replay backup logs or for replication.\r# note: if you are setting up a replication slave, see README.Debian about\r# other settings you may need to change.\r#server-id = 1\r#log_bin = /var/log/mysql/mysql-bin.log\rexpire_logs_days = 10\rmax_binlog_size = 100M\r#binlog_do_db = include_database_name\r#binlog_ignore_db = include_database_name\r#\r# * InnoDB\r#\r# InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.\r# Read the manual for more InnoDB related options. There are many!\r#\r# * Security Features\r#\r# Read the manual, too, if you want chroot!\r# chroot = /var/lib/mysql/\r#\r# For generating SSL certificates I recommend the OpenSSL GUI \u0026quot;tinyca\u0026quot;.\r#\r# ssl-ca=/etc/mysql/cacert.pem\r# ssl-cert=/etc/mysql/server-cert.pem\r# ssl-key=/etc/mysql/server-key.pem\r这样保证win10的mysqlbench可以连接到虚拟机的mysql服务器\n但是还需要在mysql中设置对应用户并使之具有外部访问的权限和操作数据库的权限，我这里直接新建gao用户并赋予外部访问权限和操作权限：\nCREATE USER 'gao'@'%' IDENTIFIED BY 'password';\r%号表示可以被任意位置访问也就允许了远程ip访问 然后给gao用户授权，使其能随意操作数据库：\nGRANT all privileges ON * TO 'gao'@'%';\r可以在mysql这个数据库内的user表内找到自己添加的用户信息\nmysql 建表添加数据等操作 建立使用的数据库USR_DB\ncreatedatabasesUSR_DB;使用USR_DB\nuseUSR_DB;建表TBL_USR\ncreatetableTBL_USR(U_IDintprimarykeyauto_increment,U_NAMEchar(10),U_GENGDERchar(10));插入表项\ninsertTBL_USR(U_NAME,U_GENGDER)values(\u0026#39;gao\u0026#39;,\u0026#39;man\u0026#39;);选取表中所有数据显示\nselect*fromTBL_USR;删除与修改表项就涉及到安全模式，mysql默认运行在安全模式所以不能进行修改和删除表项的操作，所以需要取消安全模式然后操作，操作结束后需要再设置回安全模式\nsetSQL_SAFE_UPDATES=0;deletefromTBL_USRwhereU_NAME=UNAME;setSQL_SAFE_UPDATES=1;但这样操作是有问题的，如果这三部操作是原子的，是没有问题的，但不是原子的就引入不安全的因素，其他进程可能趁这个时候错误的篡改数据，所以将这三条合成一个过程来确保操作的安全性\nDELIMITER##createprocedureproc_delete_usr(inUNAMEchar(10))beginsetSQL_SAFE_UPDATES=0;deletefromTBL_USRwhereU_NAME=UNAME;setSQL_SAFE_UPDATES=1;end##上面这个DELIMITER ##的意思就是这一段使用##作为限制符号，也就是##框住的区域视为一个整体区域，用于指示过程的区域\n定义了过程之后就可以使用call调用过程达到安全的操作：\ncallproc_delete_usr(\u0026#39;gao\u0026#39;);同样的，修改也可以这样：\nDELIMITER##createprocedureset_img(inUNAMEchar(10),UIMGBLOB)beginsetSQL_SAFE_UPDATES=0;updateTBL_USRsetU_IMG=UIMGwhereU_NAME=UNAME;setSQL_SAFE_UPDATES=1;end##callset_img(\u0026#39;gao\u0026#39;,IMG);这里的call set_img里的IMG其实在后面用于c的API调用,绑定statement之后传入的是一个char*的buffer接收的图像数据,然后设置到数据库里\n上面用到了U_IMG的column,这个列在建表时没有建立，需要使用添加column操作：\nALTERTABLETBL_USRcreatecolumnU_IMG;当然也可以使用以下操作删除：\nALTERTABLETBL_USRdropcolumnU_IMG;C api远程调用mysql 编写C程序来做到控制mysql数据库\n安装库： 先安装相关依赖和库才可以调用c api： 直接在虚拟机上\nsudo apt-get install libmysqlclient-dev;\r就安装成功了相关的c开发套件\n使用时需要在程序中包含头文件：\n#include\u0026lt;mysql.h\u0026gt;在编译相关程序时:\ngcc -o xxx xxx.c -I /usr/include/mysql -lmysqlclient 这里基本准备就完成\n基本操作: 首先需要连接mysql数据库，可以想到的就是建立一个mysql的handler，所以很自然的这里就需要一个特殊的struct，库为我们提供了MYSQL的数据类型：\nMYSQL mysql; 这样就建立了mysql这样一个handle，之后的所有操作都基于这个handle进行\n连接操作：\nif(NULL == mysql_init(\u0026amp;mysql)) { printf(\u0026#34;mysql init %s\\n\u0026#34;, mysql_error(\u0026amp;mysql)); return -1; } if(!mysql_real_connect(\u0026amp;mysql, king_db_server_ip, king_db_username, king_db_password, king_db_default_db, king_db_server_port, NULL, 0)) { printf(\u0026#34;mysql_real_connect: %s\\n\u0026#34;, mysql_error(\u0026amp;mysql)); } 可读性很高，这里不解释\n然后发送自己预定义好的sql语句：\n#define sql_insert \u0026#34;insert TBL_USR(U_NAME, U_GENGDER) values(\u0026#39;qiuxiang\u0026#39;, \u0026#39;woman\u0026#39;);\u0026#34;  #if 1 if(mysql_real_query(\u0026amp;mysql, sql_insert, strlen(sql_insert))) { printf(\u0026#34;mysql_real_query: %s\\n\u0026#34;, mysql_error(\u0026amp;mysql)); } #endif 一般情况下不进行其他操作了的话需要关闭mysql连接：\nmysql_close(\u0026amp;mysql); 以上就是简单的基于c api的mysql操作了\n其他操作 select基础\n如果需要从mysql服务器接收数据，比如select一些数据， 那么就需要一个容器来接受数据，这里使用MYSQL_RES来保存mysql的返回的结果:\n同样需要先query：\nif(mysql_real_query(mysql, sql_select, strlen(sql_select))) { printf(\u0026#34;mysql_real_query: %s\\n\u0026#34;, mysql_error(mysql)); return -1; } 然后接收数据\nMYSQL_RES *res = mysql_store_result(mysql); if(res == NULL) { printf(\u0026#34;mysql_real_query: %s\\n\u0026#34;, mysql_error(mysql)); return -2; } 然后处理数据（打印出来） 想打印的话首先需要知道行列数然后再选取需要的数据来打印：\nint rows = mysql_num_rows(res); printf(\u0026#34;rows: %d\\n\u0026#34;, rows); int fields = mysql_num_fields(res); printf(\u0026#34;fields: %d\\n\u0026#34;, fields); 再根据获取的行列数循环fetch数据行然后打印特定行列的数据\nMYSQL_ROW row; while(row = mysql_fetch_row(res)) { int i=0; for(i=0; i\u0026lt;fields;++i) { printf(\u0026#34;%s\\t\u0026#34;, row[i]); } printf(\u0026#34;\\n\u0026#34;); } 这里就可以看到，数据转存到了MYSQL_ROW这个结构中\n最后释放接收的结果\nmysql_free_result(res); statement\n使用statement来存储或发送数据到mysql服务器\n整个流程： 1、初始化stmt，使用MYSQL* handle 2、 准备statement类似于query但是不执行 3、初始化绑定参数MYSQL_BIND param，因为要insert所以要初始化buffer用于指示insert数据 4、将参数绑定到stmt上 5、将buffer中的数据通过statement发送到mysql服务器？（不太清楚是否真的发送了） 6、执行statement 7、执行完毕关闭statement\nMYSQL_STMT *stmt = mysql_stmt_init(handle); int ret = mysql_stmt_prepare(stmt, sql_insert_img, strlen(sql_insert_img)); if(ret) { printf(\u0026#34;mysql_stmt_prepare error: %s\\n\u0026#34;, mysql_error(handle)); return -2; } MYSQL_BIND param = {0}; param.buffer_type = MYSQL_TYPE_LONG_BLOB; param.buffer = NULL; param.is_null = 0; param.length = NULL; ret = mysql_stmt_bind_param(stmt, \u0026amp;param); if(ret) { printf(\u0026#34;mysql_stmt_bind_param error: %s\\n\u0026#34;, mysql_error(handle)); return -3; } ret = mysql_stmt_send_long_data(stmt, 0, buffer, length); if(ret) { printf(\u0026#34;mysql_stmt_send_long_data error: %s\\n\u0026#34;, mysql_error(handle)); return -4; } ret = mysql_stmt_execute(stmt); if(ret) { printf(\u0026#34;mysql_stmt_execute error: %s\\n\u0026#34;, mysql_error(handle)); return -5; } ret = mysql_stmt_close(stmt); if(ret) { printf(\u0026#34;mysql_stmt_close error: %s\\n\u0026#34;, mysql_error(handle)); return -6; } 以下是一个read的statement：\nMYSQL_STMT *stmt = mysql_stmt_init(handle); int ret = mysql_stmt_prepare(stmt, sql_select_img, strlen(sql_select_img)); if(ret) { printf(\u0026#34;mysql_stmt_prepare error: %s\\n\u0026#34;, mysql_error(handle)); return -2; } MYSQL_BIND result = {0}; result.buffer_type = MYSQL_TYPE_LONG_BLOB; unsigned long total_length = 0; result.length = \u0026amp;total_length; ret = mysql_stmt_bind_result(stmt, \u0026amp;result); if(ret) { printf(\u0026#34;mysql_stmt_bind_result error: %s\\n\u0026#34;, mysql_error(handle)); return -3; } ret = mysql_stmt_execute(stmt); if(ret) { printf(\u0026#34;mysql_stmt_execute error: %s\\n\u0026#34;, mysql_error(handle)); return -4; } ret = mysql_stmt_store_result(stmt); if(ret) { printf(\u0026#34;mysql_stmt_store_result error: %s\\n\u0026#34;, mysql_error(handle)); return -5; } while(1) { ret = mysql_stmt_fetch(stmt); if(ret !=0 \u0026amp;\u0026amp; ret != MYSQL_DATA_TRUNCATED) { break; } int start = 0; while(start \u0026lt; (int)total_length) { result.buffer = buffer + start; result.buffer_length = 1; mysql_stmt_fetch_column(stmt, \u0026amp;result, 0, start); start += result.buffer_length; } } mysql_stmt_close(stmt); 可以看到多了fetch操作将result的buffer成员指向外部接受用的buffer的最新的接受位置，mysql_stmt_fetch_column进行了接收工作，MYSQL_BIND result也有了新的定义方式\n","date":"2020-09-09T00:00:00Z","image":"https://example.com/p/mysql/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/mysql/","title":"Mysql基本知识"},{"content":"HTTP 实现http客户端程序\n基础 HTTP使用TCP连接 HTTP报文格式见文档\n实现 域名到ip地址转换(dns) 直接调用api进行转换比较简单：\nchar * host_to_ip(const char* hostname) { struct hostent *host_entry = gethostbyname(hostname); if(host_entry) { return inet_ntoa(*(struct in_addr*)*host_entry -\u0026gt; h_addr_list); } return NULL; } host_entry存储了dns请求的接收，从中取出第一个ip地址并将点分十进制转换为字符串返回\n创建TCP套接字（建立连接） posix api创建\nint http_create_socket(char *ip) { int sockfd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in sin = {0}; sin.sin_family = AF_INET; sin.sin_port = htons(80); sin.sin_addr.s_addr = inet_addr(ip); if(0 != connect(sockfd, (struct sockaddr*)\u0026amp;sin, sizeof(struct sockaddr_in))) { return -1; } fcntl(sockfd, F_SETFL, O_NONBLOCK); return sockfd; } fcntl(sockfd, F_SETFL, O_NONBLOCK);这个函数用于设置该套接字io为非阻塞\n通过套接字向目标网站请求资源（select）\nchar * http_send_request(const char *hostname, const char *resource) { char *ip = host_to_ip(hostname); // \tint sockfd = http_create_socket(ip); char buffer[BUFFER_SIZE] = {0}; sprintf(buffer, \u0026#34;GET %s %s\\r\\n\\ Host: %s\\r\\n\\ %s\\r\\n\\ \\r\\n\u0026#34;, resource, HTTP_VERSION, hostname, CONNECTION_TYPE ); send(sockfd, buffer, strlen(buffer), 0); //select  fd_set fdread; FD_ZERO(\u0026amp;fdread); FD_SET(sockfd, \u0026amp;fdread); struct timeval tv; tv.tv_sec = 5; tv.tv_usec = 0; char *result = malloc(sizeof(int)); memset(result, 0, sizeof(int)); while (1) { int selection = select(sockfd+1, \u0026amp;fdread, NULL, NULL, \u0026amp;tv); if (!selection || !FD_ISSET(sockfd, \u0026amp;fdread)) { break; } else { memset(buffer, 0, BUFFER_SIZE); int len = recv(sockfd, buffer, BUFFER_SIZE, 0); if (len == 0) { // disconnect \tbreak; } result = realloc(result, (strlen(result) + len + 1) * sizeof(char)); strncat(result, buffer, len); } } return result; } select部分： 首先根据套接字初始化fread来监听io，如果有消息到来就置为1，调用select函数： select(sockfd, \u0026amp;rset, \u0026amp;wset, *eset, *tv); \u0026amp;rset位置表示读监听io \u0026amp;wset位置表示写监听io \u0026amp;eset位置表示错误监听io（断开或者其他） tv为轮询间隔时间 select函数内部轮询监听这几个io，有置1就说明有信息需要处理，就返回然后处理信息 断开连接的话返回0，所以if (!selection || !FD_ISSET(sockfd, \u0026amp;fdread))可以有效控制连接断开的break 正常时返回收到的结果result\n附main函数\nint main(char argc, char*argv[]) { if(argc \u0026lt;3) { return -1; } char *response = http_send_request(argv[1], argv[2]); printf(\u0026#34;response: %s\\n\u0026#34;, response); free(response); return 1; } ","date":"2020-09-09T00:00:00Z","image":"https://example.com/p/http%E5%AE%A2%E6%88%B7%E7%AB%AF/florian-klauer-nptLmg6jqDo-unsplash_hu595aaf3b3dbbb41af5aed8d3958cc9f9_13854_120x120_fill_q75_box_smart1.jpg","permalink":"https://example.com/p/http%E5%AE%A2%E6%88%B7%E7%AB%AF/","title":"简易http客户端(C posix API)"}]