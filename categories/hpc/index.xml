<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HPC on Gao&#39;s Happy Day</title>
    <link>https://gao377020481.github.io/categories/hpc/</link>
    <description>Recent content in HPC on Gao&#39;s Happy Day</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 11 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://gao377020481.github.io/categories/hpc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Gekkofs</title>
      <link>https://gao377020481.github.io/p/gekkofs/</link>
      <pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://gao377020481.github.io/p/gekkofs/</guid>
      <description>最近在看GekkoFS，打算从理论到实现来试试能不能记下来这个分布式文件系统的实现。
他的亮点主要在于使用了系统调用拦截来直接在mount的目录上拦截相应的系统调用。
使用时还用到了一个比较少见的指令: LD_PRELOAD=&amp;lt;install_path&amp;gt;/lib64/libgkfs_intercept.so cp ~/some_input_data &amp;lt;pseudo_gkfs_mount_dir_path&amp;gt;/some_input_data 这个指令的意思是提前加载某个动态库（libgkfs_intercept.so），使用的时候将拦截的动态库提前加载进来，就可以在进入glibc的文件操作之前转向别的路径。
概述 node-local burst buffer file system.
 客户端GekkoFS client library  客户端是以库的形式提供的给HPC应用程序使用的。GekkoFS既没有实现基于fuse用户态文件系统的客户端，也没有实现VFS kernel的内核态的客户端。而是通过可以库的形式，截获所有文件系统的系统调用：如果是GekkoFS文件系统的文件，就通过网络转发给Gekkofs 服务端。如果不是GekkoFS文件系统，就调用原始的glibc库的系统调用。
Server端：GekkoFS daemon  Sever端通过本地的rocksdb来保存文件系统的元数据。 通过本地文件系统来保存数据。数据被切成同样大小的chunk（测试用512k）。
在客户端访问文件时，通过hash的方法映射到多个Server节点上。
总的来说这个架构还是很清晰的，附上论文里的图：

重点在于其工程实现，希望能从对它的代码分析中学到些有用的知识。</description>
    </item>
    
    <item>
      <title>向量化</title>
      <link>https://gao377020481.github.io/p/%E5%90%91%E9%87%8F%E5%8C%96/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://gao377020481.github.io/p/%E5%90%91%E9%87%8F%E5%8C%96/</guid>
      <description>Requirements  loop得有可以（ determinable (at run time)）确定的循环次数 loop里不能包含（inline不算）过程调用 loop里不能包含分支 迭代次数也得多 迭代之间最好也没有依赖性 理论上就算有依赖性也可以向量化但是不实用  </description>
    </item>
    
    <item>
      <title>内存优化</title>
      <link>https://gao377020481.github.io/p/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://gao377020481.github.io/p/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</guid>
      <description>从内存结构的角度来优化我们的程序。
Vector temporaries REAL V(1024,3), S(1024), U(3)DO I=1,1024S(I) = U(1)*V(I,1)END DODO I=1,1024S(I) = S(I) + U(2)*V(I,2)END DODO I=1,1024S(I) = S(I) + U(3)*V(I,3)END DODO J=1,3DO I=1,1024V(I,J) = S(I) * U(J)END DOEND DO----------------------------------------&amp;gt;REAL V(1024,3), S, U(3)DO I=1,1024S = U(1)*V(I,1) + U(2)*V(I,2) + U(3)*V(I,3)DO J=1,3V(I,J) = S * U(J)END DOEND DO将运算组织成近似向量的形式，编译器就很容易借助这种优势来将代码优化为向量的运算。</description>
    </item>
    
    <item>
      <title>编译优化</title>
      <link>https://gao377020481.github.io/p/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sun, 30 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://gao377020481.github.io/p/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</guid>
      <description>讨论一些编译器会做的优化，这些优化一般不需要我们自己来做。
但是我们讨论时从源码角度来模拟，实际上编译器是在中间代码（IR）层进行优化的。
分四部分：
IR optimisations Basic optimisations Constant folding 将一些变量转换为常量，这有助于减少内存的访问。 且常量相关的求值是可以在编译阶段就确定，不必等待运行阶段。
转换前：
integer, parameter :: n=100do i=1,n....end do转换后：
do i=1,100....end doAlgebraic simplifications 简化算术运算，包括了运用结合，交换和分配律等：
(i-j)+(i-j)+(i-j) &amp;mdash;&amp;mdash;&amp;gt; 3*i - 3*i
但是要注意浮点数操作，它不遵循结合律：
1.0 + (MF - MF) = 1.0
(1.0 + MF) - MF = 0.0
这个例子里MF比1.0大，1.0在和MF结合后会被舍去，所以第二个结果出来就是0.0了，这是因为浮点运算会先算出精确值然后舍去多余位，所以结合律失效。
Copy propagation 拷贝出来的变量在后续的使用中可以被原来的变量替代，那就少用一个寄存器。
x = yc = x + 3d = x + y--------&amp;gt;x = yc = y + 3d = y + y这里x这个变量就不需要了。</description>
    </item>
    
    <item>
      <title>Openmpi</title>
      <link>https://gao377020481.github.io/p/cmake/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gao377020481.github.io/p/cmake/</guid>
      <description>Openmpi 初步使用 安装与测试 直接官网下载release包
wget https://download.open-mpi.org/release/open-mpi/v4.1/openmpi-4.1.1.tar.gz linux下解压:
tar -zxf openmpi-4.1.1.tar.gz 进入开始configure： prefix 为指定安装路径
cd openmpi-4.1.1/ ./configure --prefix=/usr/local/openmpi 安装：
make sudo make install 设置环境变量
sudo vim /etc/profile 加入：
export PATH=/usr/local/openmpi/bin:$PATH export LD_LIBRARY_PATH=/usr/local/openmpi/lib:$LD_LIBRARY_PATH 生效：
source /etc/profile 测试
mpicc --version 写代码测试：hello.c
#include &amp;lt;stdio.h&amp;gt;#include &amp;#34;mpi.h&amp;#34; int main(int argc, char* argv[]) { int rank, size, len; char version[MPI_MAX_LIBRARY_VERSION_STRING]; MPI_Init(&amp;amp;argc, &amp;amp;argv); MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;rank); MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;size); MPI_Get_library_version(version, &amp;amp;len); printf(&amp;#34;Hello, world, I am %d of %d, (%s, %d)\n&amp;#34;, rank, size, version, len); MPI_Finalize(); return 0; } 编译并运行,我这里是四核虚拟机</description>
    </item>
    
    <item>
      <title>Spectre&amp;Meltdown</title>
      <link>https://gao377020481.github.io/p/spectremeltdown/</link>
      <pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://gao377020481.github.io/p/spectremeltdown/</guid>
      <description>Spectre&amp;amp;Meltdown
这是一种利用现代处理器特性来“窃取”内存中重要信息的漏洞。
Meltdown  诱使CPU在乱序执行的基础上将高权限的data信息放置于cache中  首先有一个数组，直接访问它的第data*4096个index处的元素 这样这个index处的元素会被放进cache中   循环遍历这个数组，当遍历到第data*4096个index处元素时，载入速度明显变快，这就说明这里是当时载入cache的元素 取到data*4096这个index就取到了data  假设data是一个内核内存空间内的数据，我们就get到了机密的内核数据，这都依赖于cpu的乱序执行：
exception(dont have priority to access))access(array[data*4096])乱序执行使得在指令生效前，access运行在了exception之前，虽然指令未生效（寄存器状态等未变），但cache内却有了array[data*4096]这个元素
Spectre Spectre基本原理与Meltdown类似，但他更强
Meltdown一旦被从根本上避免就无法使用，比如内核和用户使用不同的页目录寄存器等
Spectre并非依赖于乱序执行，而是依赖于分支预测。
分支预测也会使cpu提前跑一下cpu认为正确的分支，尽管他不一定真的是接下来要执行的，同样会在cache里留下痕迹。
但他要求代码有如下形式：
if(index1&amp;lt;array_a_size) {index2=array_a[index1];if(index2 &amp;lt; array_b_size);value = array_b[index2];}通过控制index1的长度，让array_b的特定下标的数据Cacheline被点亮，如果有办法访问一次array_b的全部内容，我们就可以窃取到index1这个值。</description>
    </item>
    
  </channel>
</rss>
